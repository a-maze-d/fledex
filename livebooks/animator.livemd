# Using the animator

```elixir
# In this example we'll use the simple setup (experiments are inteded to not run on real
# hardware but on a normal livebook, This makes it easier to stay up-to-date and experiment
# We start to define our fledex library, directly linking to the latest version on github
Mix.install([
  {:fledex, path: "Documents/code/fledex"},
  {:kino, "~>0.8"}
])

# we define a couple of aliases to not have to type that much
alias Fledex.Leds
alias Fledex.LedsDriver
alias Fledex.LedStripDriver.KinoDriver
alias Fledex.Color.Correction

:ok
```

## Section

In this example we will only use the simple setup functionality that will pick reasonable defaults

TODO: We still need to do this

```elixir
# frame = Kino.Frame.new() |> Kino.render()

{:ok, pid} = Fledex.LedsDriver.start_link(:kino)
```

We now define our animations with our dsl with the following steps:

* First we define a new strip (with a name, which will be used in the future to find out `LedsDriver` process, but not yet).
* Then within this strip we define several `live_loop`s that correspond to an animation (and will use the `LedAnimator`). Each animaation is identified by its own name
* Within each animation we define a function that will repeatedly be executed
* Inside that function we can define one or several `Leds`, either directly or through an led sequence (like a rainbow function).
* and animate those leds depending on some trigger data (data that comes into the animation function).

**Note:** The animation function itself can also create some animation by using `Leds.send()` and `Process.sleep()`, but it's better to avoid this and schedule this as part of the next function call.

**Note 2:** The `live_loop` has quite a few options to configure the behavior of various aspects of the loop, but we'll look at thos separately.

```elixir
# defmodule Test do
#   use Fledex, :strip1

#   led_strip :strip1 do
#     live_loop :anne do
#       data -> IO.puts(inspect(data))
#     end
#   end
# end

import Fledex

defmodule T do
  def func(data) do
    IO.puts(inspect(data))
    data.something + 10
  end
end

register(
  :strip1,
  [],
  :john,
  [],
  &T.func/1
)
```

```elixir
defmodule Helpers do
  def red(namespace) do
    Enum.each(1..10, fn _index ->
      LedsDriver.set_leds(namespace, [0xFF0000, 0x000000, 0x000000, 0x000000, 0x00000])
      Process.sleep(600)
      LedsDriver.set_leds(namespace, [0x000000, 0xFF0000, 0x000000, 0x000000, 0x00000])
      Process.sleep(600)
      LedsDriver.set_leds(namespace, [0x000000, 0x000000, 0xFF0000, 0x000000, 0x00000])
      Process.sleep(600)
      LedsDriver.set_leds(namespace, [0x000000, 0x000000, 0x000000, 0xFF0000, 0x00000])
      Process.sleep(600)
      LedsDriver.set_leds(namespace, [0x000000, 0x000000, 0x000000, 0x000000, 0xFF0000])
      Process.sleep(600)
    end)
  end

  def blue(namespace) do
    Enum.each(1..10, fn _index ->
      LedsDriver.set_leds(namespace, [0x000000, 0x000000, 0x000000, 0x000000, 0x0000FF, 0x00FF00])
      Process.sleep(600)
      LedsDriver.set_leds(namespace, [0x000000, 0x000000, 0x000000, 0x0000FF, 0x000000, 0x00FF00])
      Process.sleep(600)
      LedsDriver.set_leds(namespace, [0x000000, 0x000000, 0x0000FF, 0x000000, 0x000000, 0x00FF00])
      Process.sleep(600)
      LedsDriver.set_leds(namespace, [0x000000, 0x0000FF, 0x000000, 0x000000, 0x000000, 0x00FF00])
      Process.sleep(600)
      LedsDriver.set_leds(namespace, [0x0000FF, 0x000000, 0x000000, 0x000000, 0x000000, 0x00FF00])
      Process.sleep(600)
    end)
  end

  def rainbow(namespace) do
    Enum.each(0..10000, fn index ->
      config = %{
        num_leds: 50,
        reversed: true
      }

      Leds.new(50)
      |> Leds.func(:rainbow, config)
      |> Leds.send(%{namespace: namespace, offset: index})

      # before sending the next update we sleep a bit
      Process.sleep(100)
    end)
  end

  def gradient(namespace) do
    Enum.each(0..10000, fn index ->
      config = %{
        num_leds: 50,
        start_color: 0xFF0000,
        end_color: 0x0000FF
      }

      Leds.new(50)
      |> Leds.func(:gradient, config)
      |> Leds.send(%{namespace: namespace, offset: index, rotate_left: true})

      # before sending the next update we sleep a bit
      Process.sleep(100)
    end)
  end
end
```

Now use the above functions. We can run the functions by spawning a new thread. This allows to also see what happens if another thread works in parallel. Here we create a rainbow effect that will be send with an changing offset so that the rainbow rotates through the LEDs

```elixir
LedsDriver.define_namespace(:default)
spawn(fn -> Helpers.rainbow(:default) end)
```

Here we create a gradient between red and blue. Also this one we let rotate through

```elixir
LedsDriver.define_namespace(:gradient)
spawn(fn -> Helpers.gradient(:gradient) end)
```

We can drop the namespaces to see what happens

```elixir
LedsDriver.drop_namespace(:john)
LedsDriver.drop_namespace(:jane)
LedsDriver.drop_namespace(:default)
LedsDriver.drop_namespace(:gradient)
```

This test is running a couple of different ligth definitions in parallel.

```elixir
LedsDriver.define_namespace(:john)
LedsDriver.define_namespace(:jane)
LedsDriver.define_namespace(:default)

spawn(fn -> Helpers.blue(:jane) end)
spawn(fn -> Helpers.red(:john) end)
spawn(fn -> Helpers.rainbow(:default) end)
```

Once we are done we should stop our GenServer (even thoguh I rarely run this one ;-))

```elixir
GenServer.stop(pid)
```
