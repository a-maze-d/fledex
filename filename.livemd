# Untitled notebook

```elixir
Mix.install([
  {:circuits_spi, "~> 1.4", env: :prod, targets: :rpi},
  # {:telemetry, "~> 1.2"},
  {:kino, "~>0.8"},
  {:jason, "~> 1.4"}
])
```

## Section

```elixir
defmodule Fledex.Color.Types do
  defmacro __using__(_opts) do
    quote do
      @type rgb :: {red :: 0..255, green :: 0..255, blue :: 0..255}
      @type hsv :: {hue :: 0..255, saturation :: 0..255, value :: 0..255}
      @type colorint :: 0..0xFFFFFF
    end
  end
end

defmodule Fledex.Color.Names do
  @moduledoc """
  This module provides a mapping from color names to color integers
  """
  # TODO: load this json list and convert it to functions?
  # https://www.ditig.com/256-colors-cheat-sheet
  # https://www.ditig.com/downloads/256-colors.json
  defmacro __using__(_opts) do
    root_dir = Path.dirname(__DIR__)
    file = "#{root_dir}/color/256-colors.json"
    json = File.read!(file)
    {:ok, colors} = Jason.decode(json, keys: :atoms)

    names_and_rgb =
      Enum.map(colors, fn %{hexString: hex_string, name: name} ->
        hex_string = String.replace(hex_string, "#", "")
        {hex_int, _} = Integer.parse(hex_string, 16)
        atom_name = String.to_atom(String.downcase(name, :ascii))
        {atom_name, hex_int}
      end)
      |> Map.new()

    # names = Enum.map(names_and_rgb, fn {name, _} -> String.to_atom(name) end)
    quote do
      @colors unquote(Macro.escape(colors))
      @names_and_rgb unquote(Macro.escape(names_and_rgb))
      def json() do
        @colors
      end

      def names() do
        Map.keys(@names_and_rgb)
      end

      def get_color_int(name) do
        Map.fetch!(@names_and_rgb, name)
      end
    end
  end
end

defmodule Fledex.Color.Conversion.Approximate do
  use Fledex.Color.Types

  @hue_red 0
  @hue_orange 32
  @hue_yellow 64
  @hue_green 96
  @hue_aqua 128
  @hue_blue 160
  @hue_purple 192
  @hue_pink 224

  alias Fledex.Color.Utils

  @spec rgb2hsv(rgb) :: hsv
  def rgb2hsv({r, g, b}) do
    desat = find_desaturation({r, g, b})
    {r, g, b} = {r - desat, g - desat, b - desat}
    s = 255 - desat

    s =
      if s != 255 do
        255 - trunc(:math.sqrt((255 - s) * 256))
      else
        s
      end

    if r + g + b == 0 do
      {0, 0, 255 - s}
    else
      # for desaturation
      {r, g, b} = scale_to_compensate({r, g, b}, s)
      total = r + g + b
      # for small value
      {r, g, b} = scale_to_compensate({r, g, b}, total)

      v =
        if total > 255 do
          255
        else
          v = qadd8(desat, total)
          if v != 255, do: :math.sqrt(v * 256), else: v
        end

      highest = Enum.max([r, g, b])

      h =
        case {{r, g, b}, highest} do
          {{r, 0, _b}, r} ->
            (@hue_purple + @hue_pink) / 2 + Utils.scale8(qsub8(r, 128), fixfrac8(48, 128))

          {{r, g, _b}, r} when r - g > g ->
            @hue_red + Utils.scale8(g, fixfrac8(32, 85))

          {{r, g, _b}, r} ->
            @hue_orange + Utils.scale8(qsub8(g - 85 + (171 - r), 4), fixfrac8(32, 85))

          {{r, g, 0}, g} ->
            @hue_yellow + (Utils.scale8(qsub8(171, r), 47) + Utils.scale8(qsub8(g, 171), 96)) / 2

          {{_r, g, b}, g} when g - b > b ->
            @hue_green + Utils.scale8(b, fixfrac8(32, 85))

          {{_r, g, b}, g} ->
            @hue_aqua + Utils.scale8(qsub8(b, 85), fixfrac8(8, 42))

          {{0, _g, b}, b} ->
            @hue_aqua + (@hue_blue - @hue_aqua) / 4 +
              Utils.scale8(qsub8(b, 128), fixfrac8(24, 128))

          {{r, _g, b}, b} when b - r > r ->
            @hue_blue + Utils.scale8(r, fixfrac8(32, 85))

          {{r, _g, b}, b} ->
            @hue_purple + Utils.scale8(qsub8(r, 85), fixfrac8(32, 85))
        end

      {h + 1, s, v}
    end
  end

  defp fixfrac8(n, d) do
    trunc(n * 256 / d)
  end

  @spec scale_to_compensate(rgb, byte) :: rgb
  defp scale_to_compensate({r, g, b}, s) when s < 255 do
    s = if s == 0, do: 1, else: s
    scaleup = 655_535 / s
    r = trunc(r * scaleup / 256)
    g = trunc(g * scaleup / 256)
    b = trunc(b * scaleup / 256)
    {r, g, b}
  end

  defp scale_to_compensate({r, g, b}, _s), do: {r, g, b}

  @spec find_desaturation(rgb) :: byte
  defp find_desaturation({r, g, b}) do
    #     // find desaturation
    #     uint8_t desat = 255;
    #     if( r < desat) desat = r;
    #     if( g < desat) desat = g;
    #     if( b < desat) desat = b;
    255
    |> adj_desat(r)
    |> adj_desat(g)
    |> adj_desat(b)
  end

  @spec adj_desat(byte, byte) :: byte
  defp adj_desat(desat, value)
  defp adj_desat(desat, value) when value < desat, do: value
  defp adj_desat(desat, _value), do: desat

  @spec qadd8(byte, byte) :: byte
  defp qadd8(i, j) when i + j > 255, do: 255

  defp qadd8(i, j) do
    i + j
  end

  @spec qsub8(byte, byte) :: byte
  defp qsub8(i, j) when i - j < 0, do: 0

  defp qsub8(i, j) do
    i - j
  end
end

defmodule Fledex.Color.Conversion.Raw do
  use Fledex.Color.Types

  @hsv_section_3 0x40

  @spec hsv2rgb(hsv, any) :: rgb
  def hsv2rgb({h, s, v}, _extra_color_correction) do
    invsat = 255 - s
    brightness_floor = trunc(v * invsat / 256)

    color_amplitude = v - brightness_floor

    section = trunc(h / @hsv_section_3)
    offset = rem(h, @hsv_section_3)

    rampup = offset
    rampdown = @hsv_section_3 - 1 - offset

    rampup_amp_adj = trunc(rampup * color_amplitude / (256 / 4))
    rampdown_amp_adj = trunc(rampdown * color_amplitude / (256 / 4))

    rampup_adj_with_floor = rampup_amp_adj + brightness_floor
    rampdown_adj_with_floor = rampdown_amp_adj + brightness_floor

    set_colors(section, brightness_floor, rampup_adj_with_floor, rampdown_adj_with_floor)
  end

  @spec set_colors(byte, byte, byte, byte) :: rgb
  def set_colors(section, brightness_floor, rampup_adj_with_floor, rampdown_adj_with_floor)

  def set_colors(0, brightness_floor, rampup_adj_with_floor, rampdown_adj_with_floor) do
    {rampdown_adj_with_floor, rampup_adj_with_floor, brightness_floor}
  end

  def set_colors(1, brightness_floor, rampup_adj_with_floor, rampdown_adj_with_floor) do
    {brightness_floor, rampdown_adj_with_floor, rampup_adj_with_floor}
  end

  def set_colors(_, brightness_floor, rampup_adj_with_floor, rampdown_adj_with_floor) do
    {rampup_adj_with_floor, brightness_floor, rampdown_adj_with_floor}
  end
end

defmodule Fledex.Color.Conversion.Spectrum do
  use Fledex.Color.Types

  alias Fledex.Color.Utils
  alias Fledex.Color.Conversion.Raw

  @spec hsv2rgb(hsv, (rgb -> rgb)) :: rgb
  def hsv2rgb({h, s, v}, extra_color_correction) do
    #     CHSV hsv2(hsv);
    # hsv2.hue = scale8( hsv2.hue, 191);
    # hsv2rgb_raw(hsv2, rgb);
    h = Utils.scale8(h, 191)
    Raw.hsv2rgb({h, s, v}, extra_color_correction)
  end
end

defmodule Fledex.Color.Conversion.Rainbow do
  import Bitwise
  use Fledex.Color.Types
  alias Fledex.Color.Utils

  @k255 255
  @k171 171
  @k170 170
  @k85 85

  @spec hsv2rgb(hsv, (rgb -> rgb)) :: rgb
  def hsv2rgb({h, s, v}, extra_color_correction) do
    determine_rgb(h)
    |> extra_color_correction.()
    |> desaturate(s)
    |> scale_brightness(v)
  end

  @spec determine_rgb(byte) :: rgb
  defp determine_rgb(h) do
    main = {(h &&& 0x80) > 0, (h &&& 0x40) > 0, (h &&& 0x20) > 0}
    offset = h &&& 0x1F
    offset8 = offset <<< 3

    third = Utils.scale8(offset8, Kernel.trunc(256 / 3))
    twothird = Utils.scale8(offset8, Kernel.trunc(256 * 2 / 3))
    build_rgb(main, third, twothird)
  end

  @spec build_rgb({boolean, boolean, boolean}, byte, byte) :: rgb
  defp build_rgb({false, false, false}, third, _twothird) do
    {@k255 - third, third, 0}
  end

  defp build_rgb({false, false, true}, third, _twothird) do
    {@k171, @k85 + third, 0}
  end

  defp build_rgb({false, true, false}, third, twothird) do
    {@k171 - twothird, @k170 + third, 0}
  end

  defp build_rgb({false, true, true}, third, _twothird) do
    {0, @k255 - third, third}
  end

  defp build_rgb({true, false, false}, _third, twothird) do
    {0, @k171 - twothird, @k85 + twothird}
  end

  defp build_rgb({true, false, true}, third, _twothird) do
    {third, 0, @k255 - third}
  end

  defp build_rgb({true, true, false}, third, _twothird) do
    {@k85 + third, 0, @k171 - third}
  end

  defp build_rgb({true, true, true}, third, _twothird) do
    {@k170 + third, 0, @k85 - third}
  end

  @spec desaturate(rgb, byte) :: rgb
  defp desaturate({r, g, b}, 255), do: {r, g, b}
  defp desaturate(_, 0), do: {255, 255, 255}

  defp desaturate({r, g, b}, s) do
    desat = 255 - s
    desat = Utils.scale8(desat, desat, true)
    satscale = 255 - desat
    {r, g, b} = Utils.nscale8({r, g, b}, satscale, true)

    {r + desat, g + desat, b + desat}
  end

  # scales the brightness (the v part of HSV, aka HSB)
  @spec scale_brightness(rgb, byte) :: rgb
  defp scale_brightness(rgb, 255), do: rgb
  defp scale_brightness(_, v) when (v * v) >>> 8 == 0, do: {0, 0, 0}

  defp scale_brightness({r, g, b}, v) do
    val = Utils.scale8(v, v, true)
    Utils.nscale8({r, g, b}, val, true)
  end
end

defmodule Fledex.Color.Correction do
  import Bitwise
  use Fledex.Color.Types

  alias Fledex.Color.Utils

  defmodule Color do
    # 255, 176, 240
    def typicalSMD5050(), do: 0xFFB0F0
    # 255, 176, 240
    def typicalLEDStrip(), do: 0xFFB0F0
    # 255, 224, 140
    def typical8mmPixel(), do: 0xFFE08C
    # 255, 224, 140
    def typicalPixelString(), do: 0xFFE08C
    # 255, 255, 255
    def uncorrectedColor(), do: 0xFFFFFF
  end

  defmodule Temperature do
    # Black Body Radiators
    # 1900 K, 255, 147, 41 */,
    def candle(), do: 0xFF9329
    # 2600 K, 255, 197, 143 */,
    def tungsten40W(), do: 0xFFC58F
    # 2850 K, 255, 214, 170 */,
    def tungsten100W(), do: 0xFFD6AA
    # 3200 K, 255, 241, 224 */,
    def halogen(), do: 0xFFF1E0
    # 5200 K, 255, 250, 244 */,
    def carbonArc(), do: 0xFFFAF4
    # 5400 K, 255, 255, 251 */,
    def highNoonSun(), do: 0xFFFFFB
    # 6000 K, 255, 255, 255 */,
    def directSunlight(), do: 0xFFFFFF
    # 7000 K, 201, 226, 255 */,
    def overcastSkyc(), do: 0xC9E2FF
    # 20000 K, 64, 156, 255 */,
    def clearBlueSky(), do: 0x409CFF

    # Gaseous Light Sources
    # Warm (yellower) flourescent light bulbs
    # 0 K, 255, 244, 229 */,
    def warmFluorescent(), do: 0xFFF4E5
    # Standard flourescent light bulbs
    # 0 K, 244, 255, 250 */,
    def standardFluorescent(), do: 0xF4FFFA
    # Cool white (bluer) flourescent light bulbs
    # 0 K, 212, 235, 255 */,
    def coolWhiteFluorescent(), do: 0xD4EBFF
    # Full spectrum flourescent light bulbs
    # 0 K, 255, 244, 242 */,
    def fullSpectrumFluorescent(), do: 0xFFF4F2
    # Grow light flourescent light bulbs
    # 0 K, 255, 239, 247 */,
    def growLightFluorescent(), do: 0xFFEFF7
    # Black light flourescent light bulbs
    # 0 K, 167, 0, 255 */,
    def blackLightFluorescent(), do: 0xA700FF
    # Mercury vapor light bulbs
    # 0 K, 216, 247, 255 */,
    def mercuryVapor(), do: 0xD8F7FF
    # Sodium vapor light bulbs
    # 0 K, 255, 209, 178 */,
    def sodiumVapor(), do: 0xFFD1B2
    # Metal-halide light bulbs
    # 0 K, 242, 252, 255 */,
    def metalHalide(), do: 0xF2FCFF
    # High-pressure sodium light bulbs
    # 0 K, 255, 183, 76 */,
    def highPressureSodium(), do: 0xFFB74C

    # Uncorrected temperature (0xFFFFFF)
    # 255, 255, 255 */
    def uncorrectedTemperature(), do: 0xFFFFFF
  end

  @spec color_correction_g2(rgb) :: rgb
  def color_correction_g2({r, g, b}) do
    {r, g >>> 2, b}
  end

  @spec color_correction_none(rgb) :: rgb
  def color_correction_none({r, g, b}) do
    {r, g, b}
  end

  @spec define_correction(byte, colorint, colorint) :: rgb
  def define_correction(scale, color_correction, temperature_correction) when scale > 0 do
    {ccr, ccg, ccb} = Utils.split_into_subpixels(color_correction)
    {tcr, tcg, tcb} = Utils.split_into_subpixels(temperature_correction)

    r = calculate_color_correction(scale, ccr, tcr)
    g = calculate_color_correction(scale, ccg, tcg)
    b = calculate_color_correction(scale, ccb, tcb)

    {r, g, b}
  end

  def define_correction(_, _, _) do
    {0, 0, 0}
  end

  @spec apply_rgb_correction(list(rgb), byte) :: list(rgb)
  def apply_rgb_correction(leds, scale) do
    Enum.map(leds, fn {r, g, b} ->
      Utils.nscale8({r, g, b}, scale, false)
    end)
  end

  @spec calculate_color_correction(byte, byte, byte) :: byte
  defp calculate_color_correction(scale, cc, ct) when cc > 0 and ct > 0 do
    work = (cc + 1) * (ct + 1) * scale
    work = work / 0x10000
    Kernel.trunc(work) &&& 0xFF
  end

  defp calculate_color_correction(_, _, _), do: 0
end

defmodule Fledex.Color.Utils do
  use Fledex.Color.Types
  use Fledex.Color.Names
  import Bitwise

  @spec scale8_video_addition(boolean, 0..255, 0..255) :: 0 | 1
  defp scale8_video_addition(false, _value, _scale), do: 0
  defp scale8_video_addition(true, value, scale) when value != 0 and scale != 0, do: 1
  defp scale8_video_addition(_, _, _), do: 0

  @spec scale8(0..255, 0..255, boolean) :: 0..255
  def scale8(value, scale, video \\ false)
  def scale8(0, _scale, _video), do: 0

  def scale8(value, scale, video) do
    addition = scale8_video_addition(video, value, scale)
    ((value * scale) >>> 8) + addition
  end

  @spec nscale8(rgb, 0..255, boolean) :: rgb
  def nscale8(rgb, scale, video \\ true)

  def nscale8({r, g, b}, scale, video) when is_integer(scale) do
    nscale8({r, g, b}, {scale, scale, scale}, video)
  end

  @spec nscale8(rgb, rgb, boolean) :: rgb
  def nscale8({r, g, b}, {sr, sg, sb}, video) do
    {scale8(r, sr, video), scale8(g, sg, video), scale8(b, sb, video)}
  end

  @doc """
  Splits the rgb-integer value into it's subpixels and returns an
  `{r,g,b}` tupel
  """
  @spec split_into_subpixels(colorint) :: rgb
  def split_into_subpixels(elem) do
    r = elem |> Bitwise.&&&(0xFF0000) |> Bitwise.>>>(16)
    g = elem |> Bitwise.&&&(0x00FF00) |> Bitwise.>>>(8)
    b = elem |> Bitwise.&&&(0x0000FF)
    {r, g, b}
  end

  @doc """
  This function adds the given subpixels `[{r1,g1,b1}, {r2,g2,b2}, ...]` together.
  The result {r1+r2+..., g1+g2+..., b1+b2+...} is probably outside of the standard
  8bit range and will have to be rescaled
  """
  @spec add_subpixels(list(rgb)) :: {pos_integer, pos_integer, pos_integer}
  def add_subpixels(elems) do
    Enum.reduce(elems, {0, 0, 0}, fn {r, g, b}, {accr, accg, accb} ->
      {r + accr, g + accg, b + accb}
    end)
  end

  @spec avg({pos_integer, pos_integer, pos_integer}, pos_integer) :: rgb
  @doc """
  This function rescales the rgb values with count (default: 1) and combines
  them to a single integer
  """
  def avg({r, g, b}, count \\ 1) do
    r = Kernel.trunc(r / count)
    g = Kernel.trunc(g / count)
    b = Kernel.trunc(b / count)
    {r, g, b}
  end

  @spec cap({pos_integer, pos_integer, pos_integer}, Range.t()) :: rgb
  def cap({r, g, b}, min_max \\ 0..255) do
    {do_cap(r, min_max), do_cap(g, min_max), do_cap(b, min_max)}
  end

  @spec do_cap(pos_integer, Range.t()) :: pos_integer
  defp do_cap(value, min..max) when min <= max do
    case value do
      value when value < min -> min
      value when value > max -> max
      value -> value
    end
  end

  @spec combine_subpixels(rgb) :: colorint
  def combine_subpixels({r, g, b}) do
    (r <<< 16) + (g <<< 8) + b
  end

  @spec convert_to_subpixels(colorint | atom | rgb) :: rgb
  def convert_to_subpixels(rgb) do
    case rgb do
      x when is_atom(x) -> get_color_int(x) |> split_into_subpixels()
      x when is_integer(x) -> split_into_subpixels(x)
      x -> x
    end
  end
end

defmodule Fledex.LedStripDriver.Driver do
  use Fledex.Color.Types

  @callback init(init_args :: map, state :: Fledex.LedDriver.t()) :: Fledex.LedDriver.t()
  @callback transfer(leds :: list(colorint), state :: Fledex.LedDriver.t()) ::
              Fledex.LedDriver.t()
  @callback terminate(reason, state :: Fledex.LedDriver.t()) :: :ok
            when reason: :normal | :shutdown | {:shutdown, term()} | term()
end

defmodule Fledex.LedStripDriver.KinoDriver do
  @behaviour Fledex.LedStripDriver.Driver

  use Fledex.Color.Types

  @default_update_freq 50
  @base16 16
  @block <<"\u2588">>

  @impl true
  @spec init(map, Fledex.LedDriver.t()) :: Fledex.LedDriver.t()
  def init(init_args, state) do
    config = %{
      update_freq: init_args[:led_strip][:config][:update_freq] || @default_update_freq,
      log_color_code: init_args[:led_strip][:config][:log_color_code] || false,
      frame: init_args[:led_strip][:config][:frame] || Kino.Frame.new() |> Kino.render()
    }

    state
    |> put_in([Access.key(:led_strip, %{}), Access.key(:config, %{})], config)
  end

  @impl true
  @spec transfer(list(colorint), Fledex.LedDriver.t()) :: Fledex.LedDriver.t()
  def transfer(leds, state) do
    counter = state.timer.counter
    update_freq = state.led_strip.config.update_freq

    if rem(counter, update_freq) == 0 and length(leds) > 0 do
      frame = state.led_strip.config.frame

      output =
        Enum.reduce(leds, <<>>, fn value, acc ->
          hex = value |> Integer.to_string(@base16) |> String.pad_leading(6, "0")
          acc <> "<span style=\"color: ##{hex}\">" <> @block <> "</span>"
        end)

      Kino.Frame.render(frame, Kino.Markdown.new(output))
    end

    state
  end

  @impl true
  @spec terminate(reason, Fledex.LedDriver.t()) :: :ok
        when reason: :normal | :shutdown | {:shutdown, term()} | term()
  def terminate(_reason, _state) do
    # nothing needs to be done here
    :ok
  end
end

defmodule Fledex.LedStripDriver.LoggerDriver do
  @behaviour Fledex.LedStripDriver.Driver
  use Fledex.Color.Types

  alias Fledex.Color.Utils

  @default_update_freq 10
  @divisor 255 / 5
  @block <<"\u2588">>

  @moduledoc """
    This is a dummy implementation of the LedStripDriver that dumps
    the binaries to IO. This can be useful if you want to run
    some tests without real hardware.
    The real implementatin probably opens a channel (if not already open)
    to the bus (like SPI) sends the data to the bus.

    Note: this module is allowed to store information in the state
    (like the channel it has oppened), so that we don't have open/close it
    all the time. Cleanup should happen in the terminate function
  """
  @impl true
  @spec init(map, Fledex.LedDriver.t()) :: Fledex.LedDriver.t()
  def init(init_args, state) do
    config = %{
      update_freq: init_args[:led_strip][:config][:update_freq] || @default_update_freq,
      log_color_code: init_args[:led_strip][:config][:log_color_code] || false
    }

    state
    |> put_in([Access.key(:led_strip, %{}), Access.key(:config, %{})], config)
  end

  @impl true
  @spec transfer(list(colorint), Fledex.LedDriver.t()) :: Fledex.LedDriver.t()
  def transfer(leds, state) do
    counter = state.timer.counter
    update_freq = state.led_strip.config.update_freq

    if rem(counter, update_freq) == 0 and length(leds) > 0 do
      log_color_code = state.led_strip.config.log_color_code

      output =
        Enum.reduce(leds, <<>>, fn value, acc ->
          if log_color_code do
            acc <> <<value>>
          else
            acc <> to_ansi_color(value) <> @block
          end
        end)

      IO.puts(output <> "\r")
    end

    state
  end

  @spec to_ansi_color(colorint) :: String.t()
  defp to_ansi_color(value) do
    {r, g, b} = Utils.split_into_subpixels(value)
    IO.ANSI.color(trunc(r / @divisor), trunc(g / @divisor), trunc(b / @divisor))
  end

  @impl true
  @spec terminate(reason, Fledex.LedDriver.t()) :: :ok
        when reason: :normal | :shutdown | {:shutdown, term()} | term()
  def terminate(_reason, _state) do
    # nothing needs to be done here
    :ok
  end
end

if Mix.target() == :rpi do
  defmodule Fledex.LedStripDriver.SpiDriver do
    @behaviour Fledex.LedStripDriver.Driver
    use Fledex.Color.Types

    import Circuits.SPI

    @impl true
    @spec init(map, Fledex.LedDriver.t()) :: Fledex.LedDriver.t()
    def init(init_args, state) do
      config = %{
        dev: init_args[:led_strip][:config][:dev] || "spidev0.0",
        mode: init_args[:led_strip][:config][:mode] || 0,
        bits_per_word: init_args[:led_strip][:config][:bits_per_word] || 8,
        speed_hz: init_args[:led_strip][:config][:speed_hz] || 1_000_000,
        delay_us: init_args[:led_strip][:config][:delay_us] || 10,
        lsb_first: init_args[:led_strip][:config][:lsb_first] || false
      }

      state
      |> put_in([:led_strip, :config], config)
      |> put_in([:led_strip, :ref], open_spi(config))
    end

    @spec open_spi(map) :: reference
    def open_spi(config) do
      {:ok, ref} =
        Circuits.SPI.open(config.dev,
          mode: config.mode,
          bits_per_word: config.bits_per_word,
          speed_hz: config.speed_hz,
          delay_us: config.delay_us,
          lsb_first: config.lsb_first
        )

      ref
    end

    @impl true
    @spect transfer(list(colorint), Fledex.LedDriver.t()) :: Fledex.LedDriver.t()
    def transfer(leds, state) do
      ref = state.led_strip.ref
      binary = Enum.reduce(leds, <<>>, fn led, acc -> acc <> <<led>> end)
      {:ok, _} = Circuits.SPI.transfer(ref, binary)
      state
    end

    @impl true
    @spec terminate(reason, Fledex.LedDriver.t()) :: :ok
          when reason: :normal | :shutdown | {:shutdown, term()} | term()
    def terminate(_reason, state) do
      Circuits.SPI.close(state.led_strip.ref)
    end
  end
end

defmodule Fledex.Functions do
  import Bitwise
  use Fledex.Color.Types

  alias Fledex.Color.Conversion
  alias Fledex.Color.Correction

  @spec step(boolean, byte) :: integer
  # Depending whether we want to reverse we move hue forward or backwards
  defp step(reversed, hue)
  defp step(false, hue), do: hue
  defp step(true, hue), do: -hue

  @spec create_rainbow_circular_hsv(pos_integer, byte, boolean) :: list(hsv)
  def create_rainbow_circular_hsv(num_leds, initialHue \\ 0, reversed \\ false)
  def create_rainbow_circular_hsv(0, _, _), do: []

  def create_rainbow_circular_hsv(num_leds, initialHue, reversed) do
    hueChange = Kernel.trunc(65535 / num_leds)

    for n <- 0..(num_leds - 1) do
      {initialHue + step(reversed, (n * hueChange) >>> 8) &&& 0xFF, 240, 255}
    end
  end

  @spec create_rainbow_circular_rgb(pos_integer, byte, boolean) :: list(rgb)
  def create_rainbow_circular_rgb(num_leds, initialHue \\ 0, reversed \\ false) do
    create_rainbow_circular_hsv(num_leds, initialHue, reversed)
    |> hsv2rgb()
  end

  @spec create_gradient_rgb(pos_integer, rgb, rgb) ::
          list(rgb)
  def create_gradient_rgb(num_leds, {sr, sg, sb} = _start_color, {er, eg, eb} = _end_color)
      when num_leds > 0 do
    rdist87 = (er - sr) <<< 7
    gdist87 = (eg - sg) <<< 7
    bdist87 = (eb - sb) <<< 7

    steps = num_leds + 1
    rdelta = trunc(rdist87 / steps) * 2
    gdelta = trunc(gdist87 / steps) * 2
    bdelta = trunc(bdist87 / steps) * 2

    r88 = sr <<< 8
    g88 = sg <<< 8
    b88 = sb <<< 8

    for n <- 1..(steps - 1) do
      {(r88 + rdelta * n) >>> 8, (g88 + gdelta * n) >>> 8, (b88 + bdelta * n) >>> 8}
    end
  end

  @spec hsv2rgb(list(hsv), (hsv, (rgb -> rgb) -> rgb), (rgb -> rgb)) :: list(rgb)
  def hsv2rgb(
        leds,
        conversion_function \\ &Conversion.Rainbow.hsv2rgb/2,
        color_correction \\ &Correction.color_correction_none/1
      ) do
    Enum.map(leds, fn hsv ->
      conversion_function.(hsv, color_correction)
    end)
  end
end

defmodule Fledex.LedsDriver do
  @behaviour GenServer
  use Fledex.Color.Types

  require Logger
  alias Fledex.LedStripDriver.LoggerDriver
  alias Fledex.Color.Utils

  @type t :: %{
          timer: %{
            disabled: boolean,
            counter: pos_integer,
            update_timeout: pos_integer,
            update_func: (t -> t),
            only_dirty_update: boolean,
            is_dirty: boolean,
            ref: reference
          },
          led_strip: %{
            merge_strategy: atom,
            driver_module: module,
            config: map
          },
          namespaces: map
        }

  @default_update_timeout 50
  @default_driver_module LoggerDriver

  # client code
  @spec start_link(map, atom | {:global, any} | {:via, atom, any}) ::
          :ignore | {:error, any} | {:ok, pid}
  def start_link(init_arg, server_name \\ __MODULE__) do
    GenServer.start_link(__MODULE__, init_arg, name: server_name)
  end

  @spec define_namespace(atom, atom) :: {:ok, atom} | {:error, String.t()}
  def define_namespace(leds_name, server_name \\ __MODULE__) do
    GenServer.call(server_name, {:define_namespace, leds_name})
  end

  @spec drop_namespace(atom, atom) :: :ok
  def drop_namespace(leds_name, server_name \\ __MODULE__) do
    GenServer.call(server_name, {:drop_namespace, leds_name})
  end

  @spec exist_namespace(atom, atom) :: boolean
  def exist_namespace(leds_name, server_name \\ __MODULE__) do
    GenServer.call(server_name, {:exist_namespace, leds_name})
  end

  @spec set_leds(atom, list(pos_integer), atom) :: :ok | {:error, String.t()}
  def set_leds(leds_name, leds, server_name \\ __MODULE__) do
    GenServer.call(server_name, {:set_leds, leds_name, leds})
  end

  # server code
  @impl true
  @spec init(map) :: {:ok, t} | {:stop, String.t()}
  def init(init_args) when is_map(init_args) do
    state = init_state(init_args)
    state = if state[:timer][:disabled] == false, do: start_timer(state), else: state

    {:ok, state}
  end

  def init(_) do
    {:stop, "Init args need to be a map"}
  end

  @spec init_state(map) :: t
  def init_state(init_args) when is_map(init_args) do
    only_dirty_update =
      if init_args[:timer][:only_dirty_update] == nil do
        false
      else
        init_args[:timer][:only_dirty_update]
      end

    is_dirty =
      if init_args[:timer][:is_dirty] == nil do
        false
      else
        init_args[:timer][:is_dirty]
      end

    state = %{
      timer: %{
        disabled: init_args[:timer][:disabled] || false,
        counter: init_args[:timer][:counter] || 0,
        update_timeout: init_args[:timer][:update_timeout] || @default_update_timeout,
        update_func: init_args[:timer][:update_func] || (&transfer_data/1),
        only_dirty_update: only_dirty_update,
        is_dirty: is_dirty,
        ref: nil
      },
      led_strip: %{
        merge_strategy: init_args[:led_strip][:merge_strategy] || :avg,
        driver_module: init_args[:led_strip][:driver_module] || @default_driver_module,
        config: init_args[:led_strip][:config] || %{}
      },
      namespaces: init_args[:namespaces] || %{}
    }

    module = state.led_strip.driver_module
    module.init(init_args, state)
  end

  @impl true
  @spec terminate(reason, state :: Fledex.LedDriver.t()) :: :ok
        when reason: :normal | :shutdown | {:shutdown, term()} | term()
  def terminate(reason, state) do
    module = state.led_strip.driver_module
    module.terminate(reason, state)
  end

  @spec start_timer(t) :: t
  defp start_timer(state) do
    update_timeout = state[:timer][:update_timeout]
    update_func = state[:timer][:update_func]

    ref = Process.send_after(self(), {:update_timeout, update_func}, update_timeout)
    state = update_in(state, [:timer, :ref], fn _current_ref -> ref end)

    state
  end

  @impl true
  @spec handle_call({:define_namespace, atom}, {pid, any}, t) ::
          {:reply, {:ok, atom} | {:error, binary}, t}
  def handle_call({:define_namespace, name}, _from, %{namespaces: namespaces} = state) do
    state = put_in(state, [:timer, :is_dirty], true)

    case Map.has_key?(namespaces, name) do
      false -> {:reply, {:ok, name}, %{state | namespaces: Map.put_new(namespaces, name, [])}}
      true -> {:reply, {:error, "namespace already exists"}, state}
    end
  end

  @impl true
  @spec handle_call({:drop_namespace, atom}, {pid, any}, t) :: {:reply, :ok, t}
  def handle_call({:drop_namespace, name}, _from, %{namespaces: namespaces} = state) do
    state = put_in(state, [:timer, :is_dirty], true)
    {:reply, :ok, %{state | namespaces: Map.drop(namespaces, [name])}}
  end

  @impl true
  @spec handle_call({:exist_namespace, atom}, {pid, any}, t) :: {:reply, boolean, t}
  def handle_call({:exist_namespace, name}, _from, %{namespaces: namespaces} = state) do
    exists =
      case Map.fetch(namespaces, name) do
        {:ok, _} -> true
        _ -> false
      end

    {:reply, exists, state}
  end

  @impl true
  @spec handle_call({:set_leds, atom, list(colorint)}, {pid, any}, t) ::
          {:reply, :ok | {:error, String.t()}, t}
  def handle_call({:set_leds, name, leds}, _from, %{namespaces: namespaces} = state) do
    state = put_in(state, [:timer, :is_dirty], true)

    case Map.has_key?(namespaces, name) do
      true ->
        {:reply, :ok, %{state | namespaces: Map.put(namespaces, name, leds)}}

      false ->
        {:reply,
         {:error, "no such namespace, you need to define one first with :define_namespace"},
         state}
    end
  end

  @impl true
  @spec handle_info({:update_timeout, (t -> t)}, t) :: {:noreply, t}
  def handle_info({:update_timeout, func}, state) do
    # here should now come some processing for now we just increase the counter and reschdule the timer
    state = update_in(state, [:timer, :counter], &(&1 + 1))
    state = start_timer(state)

    # Logger.info "calling #{inspect func}"
    state = func.(state)

    {:noreply, state}
  end

  @spec transfer_data(t) :: t
  def transfer_data(
        %{timer: %{is_dirty: is_dirty, only_dirty_updates: only_dirty_updates}} = state
      )
      when only_dirty_updates == true and is_dirty == false do
    # we shortcut if there is nothing to update and if we are allowed to shortcut
    state
  end

  def transfer_data(state) do
    # state = :telemetry.span(
    #   [:transfer_data],
    #   %{timer_counter: state.timer.counter},
    #   fn ->
    state =
      state.namespaces
      |> merge_namespaces(state.led_strip.merge_strategy)
      |> send_to_strip(state)
      |> put_in([:timer, :is_dirty], false)

    #       {state, %{metadata: "done"}}
    #   end
    # )
    state
  end

  @spec merge_namespaces(map, atom) :: list(colorint)
  def merge_namespaces(namespaces, merge_strategy) do
    namespaces
    |> get_leds()
    |> merge_leds(merge_strategy)
  end

  @spec get_leds(map) :: list(list(colorint))
  def get_leds(namespaces) do
    Enum.reduce(namespaces, [], fn {_key, value}, acc ->
      acc ++ [value]
    end)
  end

  @spec merge_leds(list(list(colorint)), atom) :: list(colorint)
  def merge_leds(leds, merge_strategy) do
    leds = match_length(leds)

    Enum.zip_with(leds, fn elems ->
      merge_pixels(elems, merge_strategy)
    end)
  end

  @spec match_length(list(list(colorint))) :: list(list(colorint))
  def match_length(leds) when leds == nil, do: leds
  def match_length(leds) when length(leds) == 0, do: leds

  def match_length(leds) do
    max_length = Enum.reduce(leds, 0, fn sequence, acc -> max(acc, length(sequence)) end)
    Enum.map(leds, fn sequence -> extend(sequence, max_length - length(sequence)) end)
  end

  @spec extend(list(colorint), pos_integer) :: list(colorint)
  def extend(sequence, 0), do: sequence

  def extend(sequence, extra) do
    extra_length = Enum.reduce(1..extra, [], fn _index, acc -> acc ++ [0x000000] end)
    sequence ++ extra_length
  end

  @spec merge_pixels(list(colorint), atom) :: colorint
  def merge_pixels(elems, merge_strategy) do
    count = length(elems)

    elems
    |> Enum.map(fn elem -> Utils.split_into_subpixels(elem) end)
    |> Utils.add_subpixels()
    |> apply_merge_strategy(count, merge_strategy)
    |> Utils.combine_subpixels()
  end

  @spec apply_merge_strategy({pos_integer, pos_integer, pos_integer}, pos_integer, atom) :: rgb
  def apply_merge_strategy(rgb, count, merge_strategy) do
    case merge_strategy do
      :avg -> Utils.avg(rgb, count)
      :cap -> Utils.cap(rgb)
      _ -> raise "Unknown merge strategy"
    end
  end

  @spec send_to_strip(list(colorint), t) :: t
  defp send_to_strip(leds, state) do
    module = state.led_strip.driver_module
    module.transfer(leds, state)
  end
end

defmodule Fledex.Leds do
  import Bitwise

  use Fledex.Color.Types
  use Fledex.Color.Names

  require Logger

  alias Fledex.Functions
  alias Fledex.LedsDriver
  alias Fledex.Color.Utils

  @enforce_keys [:count, :leds, :opts]
  # , fill: :none
  defstruct count: 0, leds: %{}, opts: %{}, meta: %{index: 1}
  @type t :: %__MODULE__{count: integer, leds: map, opts: map, meta: map}

  @func_ids %{
    rainbow: &Fledex.Leds.rainbow/2,
    gradient: &Fledex.Leds.gradient/2
  }

  @spec new() :: t
  def new() do
    new(0)
  end

  @spec new(integer) :: t
  def new(count) do
    new(count, %{})
  end

  @spec new(integer, map) :: t
  def new(count, opts) do
    new(count, %{}, opts)
  end

  @spec new(integer, map, map) :: t
  def new(count, leds, opts) do
    new(count, leds, opts, %{index: 1})
  end

  @spec new(integer, map, map, map) :: t
  def new(count, leds, opts, meta) do
    %__MODULE__{count: count, leds: leds, opts: opts, meta: meta}
  end

  @spec rainbow(t, map) :: t
  def rainbow(leds, config) do
    num_leds = config[:num_leds] || leds.count
    initial_hue = config[:initial_hue] || 0
    reversed = if config[:reversed], do: config[:reversed], else: false
    offset = config[:offset] || 0

    led_values =
      Functions.create_rainbow_circular_rgb(num_leds, initial_hue, reversed)
      |> convert_to_leds_structure(offset)

    put_in(leds.leds, Map.merge(leds.leds, led_values))
  end

  @spec convert_to_leds_structure(list(rgb), integer) :: map
  def convert_to_leds_structure(rgbs, offset \\ 0) do
    offset_oneindex = offset + 1

    Enum.zip_with(offset_oneindex..(offset_oneindex + length(rgbs)), rgbs, fn index, {r, g, b} ->
      {index, (r <<< 16) + (g <<< 8) + b}
    end)
    |> Map.new()
  end

  @spec gradient(t, map) :: t
  def gradient(leds, %{start_color: start_color, end_color: end_color} = config) do
    num_leds = config[:num_leds] || leds.count
    offset = config[:offset] || 0

    start_color = Utils.convert_to_subpixels(start_color)
    end_color = Utils.convert_to_subpixels(end_color)

    led_values =
      Functions.create_gradient_rgb(num_leds, start_color, end_color)
      |> convert_to_leds_structure(offset)

    put_in(leds.leds, Map.merge(leds.leds, led_values))
  end

  def gradient(_leds, _config) do
    raise "You need to specify at least a start_color and end_color"
  end

  @spec light(t, colorint | t | atom) :: t
  def light(leds, rgb) do
    do_update(leds, rgb)
  end

  @spec light(t, colorint | t | atom, pos_integer) :: t
  def light(leds, led, offset) do
    do_update(leds, led, offset)
  end

  @spec func(t, atom, map) :: t
  def func(leds, func_id, config \\ %{}) do
    func = @func_ids[func_id]
    func.(leds, config)
  end

  @spec update(t, colorint | rgb | atom) :: t
  def update(leds, led) do
    do_update(leds, led)
  end

  @doc """
  :offset is 1 indexed. Offset needs to be >0 if it's bigger than the :count
  then the led will be stored, but ignored
  """
  @spec update(t, colorint | t, pos_integer) :: t
  def update(leds, led, offset) when offset > 0 do
    do_update(leds, led, offset)
  end

  def update(_leds, _led, offset) do
    raise ArgumentError, message: "the offset needs to be > 0 (found: #{offset})"
  end

  @spec do_update(t, colorint | rgb | atom) :: t
  defp do_update(%__MODULE__{meta: meta} = leds, rgb) do
    index = meta[:index] || 1
    do_update(leds, rgb, index)
  end

  @spec do_update(t, colorint, pos_integer) :: t
  defp do_update(%__MODULE__{count: count, leds: leds, opts: opts, meta: meta}, rgb, offset)
       when is_integer(rgb) do
    __MODULE__.new(count, Map.put(leds, offset, rgb), opts, %{meta | index: offset + 1})
  end

  @spec do_update(t, t, pos_integer) :: t
  defp do_update(
         %__MODULE__{count: count1, leds: leds1, opts: opts1, meta: meta1},
         %__MODULE__{count: count2, leds: leds2},
         offset
       ) do
    # remap the indicies (1 indexed)
    remapped_new_leds =
      Map.new(
        Enum.map(leds2, fn {key, value} ->
          index = offset + key - 1
          {index, value}
        end)
      )

    leds = Map.merge(leds1, remapped_new_leds)
    __MODULE__.new(count1, leds, opts1, %{meta1 | index: offset + count2})
  end

  @spec do_update(t, atom, pos_integer) :: t
  defp do_update(leds, atom, offset) when is_atom(atom) do
    color_int = get_color_int(atom)
    do_update(leds, color_int, offset)
  end

  defp do_update(leds, led, offset) do
    raise ArgumentError,
      message: "unknown data #{inspect(leds)}, #{inspect(led)}, #{inspect(offset)}"
  end

  @spec to_binary(t) :: binary
  def to_binary(%__MODULE__{count: count, leds: _leds, opts: _opts, meta: _meta} = leds) do
    Enum.reduce(1..count, <<>>, fn index, acc ->
      acc <> <<get_light(leds, index)>>
    end)
  end

  @spec to_list(t) :: list[integer]
  def to_list(%__MODULE__{count: count, leds: _leds, opts: _opts, meta: _meta} = leds) do
    Enum.reduce(1..count, [], fn index, acc ->
      acc ++ [get_light(leds, index)]
    end)
  end

  @spec send(t, map) :: any
  def send(leds, opts \\ %{}) do
    leds_name = opts[:leds_name] || :default
    server_name = opts[:server_name] || Fledex.LedsDriver
    offset = opts[:offset] || 0
    rotate_left = if opts[:rotate_left] != nil, do: opts[:rotate_left], else: true

    # we probably want to do some validation here and probably
    # want to optimise it a bit
    # a) is the server running?
    if Process.whereis(server_name) == nil do
      Logger.warn("The server wasn't started. You should start it before using this function")
      {:ok, _pid} = LedsDriver.start_link(%{}, server_name)
    end

    # b) Is a namespace defined?
    exists = LedsDriver.exist_namespace(leds_name, server_name)

    if not exists do
      Logger.warn(
        "The namespace hasn't been defined. This should be done before calling this function"
      )

      LedsDriver.define_namespace(leds_name, server_name)
    end

    vals = rotate(to_list(leds), offset, rotate_left)
    LedsDriver.set_leds(leds_name, vals, server_name)
  end

  @spec get_light(t, pos_integer) :: colorint
  def get_light(%__MODULE__{leds: leds} = _leds, index) do
    case Map.fetch(leds, index) do
      {:ok, value} -> value
      _ -> 0
    end
  end

  @spec rotate(list(colorint), pos_integer, boolean) :: list(colorint)
  def rotate(vals, offset, rotate_left \\ true)
  def rotate(vals, 0, _rotate_left), do: vals

  def rotate(vals, offset, rotate_left) do
    count = Enum.count(vals)
    offset = rem(offset, count)
    offset = if rotate_left, do: offset, else: count - offset
    Enum.slide(vals, 0..rem(offset - 1 + count, count), count)
  end
end
```
